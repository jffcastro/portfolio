        <!-- Total Portfolio Value (Multi-currency) -->
        <div id="portfolio-total-value-bar" class="w-full flex justify-center items-center mb-4">
            <div class="bg-emerald-700 text-white text-xl md:text-2xl font-bold px-4 md:px-8 py-3 rounded-xl shadow-lg border-4 border-emerald-400 flex flex-col md:flex-row gap-2 md:gap-6 items-center justify-center">
                <span>Total Portfolio Value:</span>
                <span id="portfolio-total-eur">€0.00</span>
                <span id="portfolio-total-usd">$0.00</span>
                <span id="portfolio-total-btc">₿0.0000</span>
                <span id="portfolio-total-eth">Ξ0.0000</span>
            </div>
        </div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>João's Journey</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Hide dropdown arrow for disabled select */
        select:disabled {
            background-image: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            color-scheme: dark;
        }
        /* Hide number input spinners for CS2 items box */
        #cs2-value-input::-webkit-outer-spin-button,
        #cs2-value-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #cs2-value-input[type=number] {
            -moz-appearance: textfield;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        .positive-gain { color: #22c55e; /* green-500 */ }
        .negative-gain { color: #ef4444; /* red-500 */ }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body class="text-white">


    <div class="container mx-auto p-4 md:p-6">
        <!-- Header: João's Journey and all buttons -->
        <header class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
            <div class="flex flex-col md:flex-row items-center gap-2 w-full">
                <h1 class="text-2xl md:text-3xl font-bold mr-4">João's Journey</h1>
                <div class="flex items-center gap-2">
                    <span id="eur-usd-rate-label" class="text-lg text-emerald-400 font-semibold"></span>
                    <span id="eur-btc-rate-label" class="text-lg text-yellow-400 font-semibold"></span>
                    <span id="eur-eth-rate-label" class="text-lg text-yellow-300 font-semibold"></span>
                    <button id="fetch-rates-btn" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">Fetch Rates</button>
                </div>
            </div>
            <div class="flex flex-col md:flex-row w-full md:w-auto justify-between items-center gap-2">
                <div class="flex items-center space-x-2">
                    <input type="file" id="csv-import" class="hidden" accept=".csv">
                    <input type="file" id="history-csv-import" class="hidden" accept=".csv">
                    <button id="import-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded transition duration-300 text-xs">Import CSV</button>
                    <button id="export-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded transition duration-300 text-xs">Export CSV</button>
                    <button id="import-history-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded transition duration-300 text-xs">Import History</button>
                    <button id="export-history-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded transition duration-300 text-xs">Export History</button>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="delete-storage-btn" class="bg-red-700 hover:bg-red-800 text-white font-bold py-1 px-2 rounded transition duration-300 text-xs">Delete Local</button>
                </div>
            </div>
        </header>

        <!-- Portfolio Value Summary and Pie Chart Row -->
        <div class="flex flex-col md:flex-row md:items-start gap-6 mb-6">
            <div class="flex-1">
                <!-- Portfolio History Chart remains here -->
                <div class="bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg mb-6">
                    <h2 class="text-xl font-semibold mb-4">Portfolio History</h2>
                    <div class="flex justify-between items-center mb-4">
                        <button id="validate-history-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Add to History</button>
                    </div>
                    <div class="h-64 md:h-80">
                        <canvas id="portfolio-chart"></canvas>
                    </div>
                </div>
                <!-- Multi-currency Timeline Chart -->
                <div class="bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg mb-6">
                    <h2 class="text-xl font-semibold mb-4">Portfolio Value (EUR, USD, BTC, ETH)</h2>
                    <div class="h-64 md:h-80">
                        <canvas id="portfolio-multicurrency-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="w-full md:w-96 flex-shrink-0">
                <div class="bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4">Portfolio Breakdown</h2>
                    <div class="h-64 md:h-80 relative">
                        <canvas id="pie-chart"></canvas>
                        <div id="pie-legend-container" class="absolute top-0 right-0 h-full overflow-y-auto bg-gray-900 bg-opacity-80 rounded-lg p-2 w-48 md:w-56 text-sm flex flex-col gap-1 z-10" style="max-height: 100%; display: none;"></div>
                    </div>
                </div>
            </div>
        </div>

        
        <!-- Main Content Grid -->

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Cash & Savings + CS2 Row -->
            <div class="lg:col-span-3 flex flex-col lg:flex-row gap-6">
                <!-- Cash & Savings Accounts -->
                <div class="flex-1 bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                        Cash & Savings Accounts
                        <button id="add-static-btn" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">+ Add Asset</button>
                    </h2>
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="py-2 px-4">Asset</th>
                                    <th class="py-2 px-4">Value</th>
                                    <th class="py-2 px-4">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="static-tbody">
                               <!-- JS will populate this -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <!-- CS2 Items -->
                <div class="w-full lg:w-96 flex-shrink-0 bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><circle cx="12" cy="12" r="10"></circle><path d="M12 8v4l3 3"></path></svg>
                        CS2 Items
                    </h2>
                    <div class="flex items-center gap-4 mb-2">
                        <label for="cs2-value-input" class="block text-lg font-medium">Total Value:</label>
                        <span class="text-xl font-bold text-gray-300">$</span>
                        <input type="number" id="cs2-value-input" class="bg-gray-700 text-white rounded-lg px-4 py-2 w-40" min="0" step="0.01" placeholder="Enter value" />
                        <button id="save-cs2-value-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save</button>
                    </div>
                    <div class="text-gray-400 text-sm">
                        Manually input the total value of your CS2 items.<br>
                        <span class="italic">Note: This value should always be in <b>USD</b>. It will be automatically converted to EUR in the total portfolio value.</span>
                    </div>
                </div>
            </div>

            <!-- Stocks -->
            <div class="lg:col-span-2 bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
                    Stocks
                    <button id="get-stocks-prices-btn" class="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">Get Prices</button>
                    <button id="add-stock-btn" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">+ Add Asset</button>
                </h2>
                <div class="overflow-x-auto">
                    <table class="w-full text-left">
                        <thead>
                            <tr class="border-b border-gray-700">
                                <th class="py-2 px-4">Asset</th>
                                <th class="py-2 px-4">Quantity</th>
                                <th class="py-2 px-4">Avg. Price</th>
                                <th class="py-2 px-4">Price</th>
                                <th class="py-2 px-4">Total Invested</th>
                                <th class="py-2 px-4">Value</th>
                                <th class="py-2 px-4">Gain/Loss</th>
                                <th class="py-2 px-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="stocks-tbody">
                           <!-- JS will populate this -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- ETFs -->
            <div class="lg:col-span-2 bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg mt-6">
                <h2 class="text-xl font-semibold mb-4 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                    ETFs
                    <button id="get-etfs-prices-btn" class="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">Get Prices</button>
                    <button id="add-etf-btn" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">+ Add Asset</button>
                </h2>
                <div class="overflow-x-auto">
                    <table class="w-full text-left">
                        <thead>
                            <tr class="border-b border-gray-700">
                                <th class="py-2 px-4">Asset</th>
                                <th class="py-2 px-4">Quantity</th>
                                <th class="py-2 px-4">Avg. Price</th>
                                <th class="py-2 px-4">Price</th>
                                <th class="py-2 px-4">Total Invested</th>
                                <th class="py-2 px-4">Value</th>
                                <th class="py-2 px-4">Gain/Loss</th>
                                <th class="py-2 px-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="etfs-tbody">
                           <!-- JS will populate this -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Crypto -->
            <div class="lg:col-span-3 bg-gray-800 p-4 md:p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M10.4 3.9a1 1 0 0 0-1.8 0l-2.8 5.4a1 1 0 0 0 .9 1.5h9a1 1 0 0 0 .9-1.5Z"></path><path d="M10.4 20.1a1 1 0 0 0-1.8 0l-2.8-5.4a1 1 0 0 0 .9-1.5h9a1 1 0 0 0 .9 1.5Z"></path></svg>
                    Crypto
                    <button id="get-crypto-prices-btn" class="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">Get Prices</button>
                    <button id="add-crypto-btn" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded transition duration-300 text-xs">+ Add Asset</button>
                </h2>
                <div class="overflow-x-auto">
                     <table class="w-full text-left">
                        <thead>
                            <tr class="border-b border-gray-700">
                                <th class="py-2 px-4">Asset</th>
                                <th class="py-2 px-4">Quantity</th>
                                <th class="py-2 px-4">Avg. Price</th>
                                <th class="py-2 px-4">Price</th>
                                <th class="py-2 px-4">Total Invested</th>
                                <th class="py-2 px-4">Value</th>
                                <th class="py-2 px-4">Gain/Loss</th>
                                <th class="py-2 px-4">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="crypto-tbody">
                           <!-- JS will populate this -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    </div>

    <!-- Add Asset Modal -->
    <div id="asset-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop hidden">
        <div class="bg-gray-800 w-full max-w-md p-6 rounded-xl shadow-lg mx-4">
            <h2 id="modal-title" class="text-2xl font-bold mb-6">Add New Asset</h2>
            <form id="asset-form">
                <input type="hidden" id="asset-id">
                <div class="mb-4">
                    <label for="asset-type" class="block mb-2">Asset Type</label>
                    <select id="asset-type" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500">
                        <option value="stock">Stock</option>
                        <option value="etf">ETF</option>
                        <option value="crypto">Crypto</option>
                        <option value="static">Cash & Savings</option>
                    </select>
                </div>
                <div id="static-type-field" class="mb-4 hidden">
                    <label for="static-type" class="block mb-2">Static Asset Type</label>
                    <select id="static-type" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500">
                        <option value="Savings">Savings</option>
                        <option value="Emergency Fund">Emergency Fund</option>
                        <option value="Cash">Cash</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label for="asset-name" id="asset-name-label" class="block mb-2">Ticker (e.g., AAPL)</label>
                    <input type="text" id="asset-name" placeholder="e.g., AAPL" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500" required>
                </div>
                <div id="quantity-field" class="mb-4">
                    <label for="asset-quantity" class="block mb-2">Quantity</label>
                    <input type="number" id="asset-quantity" step="any" placeholder="e.g., 10" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500" required>
                </div>
                <div id="purchase-price-field" class="mb-4">
                    <label for="asset-purchase-price" class="block mb-2">Average Purchase Price</label>
                    <input type="number" id="asset-purchase-price" step="any" placeholder="e.g., 150.25" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500" required>
                </div>
                <div class="mb-4">
                    <label for="asset-currency" class="block mb-2">Currency</label>
                    <select id="asset-currency" class="w-full bg-gray-700 p-2 rounded-lg border border-gray-600 focus:outline-none focus:border-green-500">
                        <option value="EUR">EUR</option>
                        <option value="USD">USD</option>
                    </select>
                </div>
    <!-- Removed Get Exchange Rate button and label -->
                <div class="flex justify-end space-x-4">
                    <button type="button" id="cancel-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Save Asset</button>
                </div>
            </form>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {
    // Initialize multi-currency chart
    let multiCurrencyChartInstance = null;
    function initializeMultiCurrencyChart() {
        const ctx = document.getElementById('portfolio-multicurrency-chart').getContext('2d');
        multiCurrencyChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'EUR', data: [], borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.1)', borderWidth: 3, tension: 0.1, fill: false },
                    { label: 'USD', data: [], borderColor: '#3b82f6', backgroundColor: 'rgba(59,130,246,0.1)', borderWidth: 2, tension: 0.1, fill: false },
                    { label: 'BTC', data: [], borderColor: '#f59e42', backgroundColor: 'rgba(245,158,66,0.1)', borderWidth: 2, tension: 0.1, fill: false },
                    { label: 'ETH', data: [], borderColor: '#a78bfa', backgroundColor: 'rgba(167,139,250,0.1)', borderWidth: 2, tension: 0.1, fill: false }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: false, ticks: { color: '#9ca3af' }, grid: { color: '#374151' } },
                    x: { ticks: { color: '#9ca3af' }, grid: { color: '#374151' } }
                },
                plugins: { legend: { labels: { color: '#d1d5db' } } }
            }
        });
    }

    function updateMultiCurrencyChart() {
        if (!multiCurrencyChartInstance) return;
        const validatedHistory = loadValidatedHistory();
        if (!validatedHistory.length) {
            multiCurrencyChartInstance.data.labels = [];
            multiCurrencyChartInstance.data.datasets.forEach(ds => ds.data = []);
            multiCurrencyChartInstance.update();
            return;
        }
        validatedHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        multiCurrencyChartInstance.data.labels = validatedHistory.map(h => h.date);
        // Get arrays for each currency
        const eurArr = validatedHistory.map(h => h.eur ?? null);
        const usdArr = validatedHistory.map(h => h.usd ?? null);
        const btcArr = validatedHistory.map(h => h.btc ?? null);
        const ethArr = validatedHistory.map(h => h.eth ?? null);
        // Find first non-null value for each
        const firstEur = eurArr.find(v => v != null && !isNaN(v));
        const firstUsd = usdArr.find(v => v != null && !isNaN(v));
        const firstBtc = btcArr.find(v => v != null && !isNaN(v));
        const firstEth = ethArr.find(v => v != null && !isNaN(v));
        // Normalize to 100
        multiCurrencyChartInstance.data.datasets[0].data = eurArr.map(v => (v != null && firstEur) ? (v / firstEur) * 100 : null);
        multiCurrencyChartInstance.data.datasets[1].data = usdArr.map(v => (v != null && firstUsd) ? (v / firstUsd) * 100 : null);
        multiCurrencyChartInstance.data.datasets[2].data = btcArr.map(v => (v != null && firstBtc) ? (v / firstBtc) * 100 : null);
        multiCurrencyChartInstance.data.datasets[3].data = ethArr.map(v => (v != null && firstEth) ? (v / firstEth) * 100 : null);
        multiCurrencyChartInstance.options.plugins.legend.title = { display: true, text: 'Indexed to 100 at first entry' };
        multiCurrencyChartInstance.options.scales.y.suggestedMin = 80;
        multiCurrencyChartInstance.options.scales.y.suggestedMax = 120;
        multiCurrencyChartInstance.update();
    }

    setTimeout(() => {
        initializeMultiCurrencyChart();
        updateMultiCurrencyChart();
    }, 0);
    // --- FETCH RATES BUTTON ---
    const fetchRatesBtn = document.getElementById('fetch-rates-btn');
    if (fetchRatesBtn) {
        fetchRatesBtn.addEventListener('click', async () => {
            fetchRatesBtn.disabled = true;
            fetchRatesBtn.textContent = 'Fetching...';
            let success = true;
            // Fetch EUR/USD
            try {
                const res = await fetch('https://api.frankfurter.app/latest?from=EUR&to=USD');
                const data = await res.json();
                if (data && data.rates && data.rates.USD) {
                    saveExchangeRate(data.rates.USD);
                    showNotification('Exchange rate updated!', 'success');
                } else {
                    showNotification('Failed to fetch exchange rate', 'error');
                    success = false;
                }
            } catch (e) {
                showNotification('Error fetching exchange rate', 'error');
                success = false;
            }
            // Fetch Crypto Rates (BTC/ETH)
            try {
                const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=eur');
                const data = await res.json();
                if (data.bitcoin && data.bitcoin.eur && data.ethereum && data.ethereum.eur) {
                    setCachedCryptoRates(data.bitcoin.eur, data.ethereum.eur);
                    showNotification('Crypto rates updated!', 'success');
                } else {
                    showNotification('Failed to fetch crypto rates: ' + JSON.stringify(data), 'error');
                    success = false;
                }
            } catch (e) {
                showNotification('Error fetching crypto rates: ' + (e && e.message ? e.message : e), 'error');
                success = false;
            }
            renderPortfolio();
            fetchRatesBtn.disabled = false;
            fetchRatesBtn.textContent = 'Fetch Rates';
        });
    }
    // Show/hide static type field based on asset type
    // Static asset type selector logic is handled in main JS block below to avoid duplicate declarations

    // --- EXCHANGE RATE STATE ---
    // --- DELETE LOCAL STORAGE BUTTON ---
    document.getElementById('delete-storage-btn').addEventListener('click', () => {
        if (confirm('Are you sure you want to delete all local storage and reset the app?')) {
            // Remove all relevant keys
            localStorage.removeItem('portfolioPilotData');
            localStorage.removeItem('portfolioPilotValidatedHistory');
            localStorage.removeItem('portfolioPilotPriceCache');
            localStorage.removeItem('eurUsdRate');
            // Optionally clear all localStorage (uncomment next line if you want to clear everything):
            // localStorage.clear();
            location.reload();
        }
    });
    let eurUsdRate = 1.0;
    function loadExchangeRate() {
        const stored = localStorage.getItem('eurUsdRate');
        if (stored) {
            eurUsdRate = parseFloat(stored);
        }
        updateExchangeRateLabel();
    }
    function saveExchangeRate(rate) {
        eurUsdRate = rate;
        localStorage.setItem('eurUsdRate', rate);
        updateExchangeRateLabel();
    }
    function updateExchangeRateLabel() {
        const label = document.getElementById('eur-usd-rate-label');
        if (label) {
            label.textContent = `EUR/USD: ${eurUsdRate}`;
        }
    }
    async function fetchExchangeRate() {
        try {
            const res = await fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD');
            const data = await res.json();
            if (data && data.rates && data.rates.USD) {
                saveExchangeRate(data.rates.USD);
                showNotification('Exchange rate updated!', 'success');
            } else {
                showNotification('Failed to fetch exchange rate', 'error');
            }
        } catch (e) {
            showNotification('Error fetching exchange rate', 'error');
        }
    }

    // --- IMPORTANT ---
    // For Crypto Prices: CoinGecko -> https://www.coingecko.com/en/api
    // No API key needed for Yahoo Finance stock prices.
    
    // --- STATE MANAGEMENT ---
    let portfolio = {
    stocks: [],
    etfs: [],
    crypto: [],
    static: [], // Each static asset: { id, name, type, values: [{date, value, currency}] }
    cs2: { value: 0, currency: 'EUR' }
    };

    let chartInstance = null;
    
    // --- DOM ELEMENTS ---
    // const addAssetBtn = document.getElementById('add-asset-btn');
    const addStockBtn = document.getElementById('add-stock-btn');
    const addEtfBtn = document.getElementById('add-etf-btn');
    const addCryptoBtn = document.getElementById('add-crypto-btn');
    const addStaticBtn = document.getElementById('add-static-btn');
    const modal = document.getElementById('asset-modal');
    const modalTitle = document.getElementById('modal-title');
    const cancelBtn = document.getElementById('cancel-btn');
    const assetForm = document.getElementById('asset-form');
    const assetTypeSelect = document.getElementById('asset-type');
    const staticTypeField = document.getElementById('static-type-field');
    const assetNameInput = document.getElementById('asset-name');
    const assetNameLabel = document.getElementById('asset-name-label');
    const assetQuantityInput = document.getElementById('asset-quantity');
    const assetPurchasePriceInput = document.getElementById('asset-purchase-price');
    const quantityField = document.getElementById('quantity-field');
    const purchasePriceField = document.getElementById('purchase-price-field');
    const assetIdInput = document.getElementById('asset-id');
    const assetCurrencySelect = document.getElementById('asset-currency');
    const stocksTbody = document.getElementById('stocks-tbody');
    const etfsTbody = document.getElementById('etfs-tbody');
    const cryptoTbody = document.getElementById('crypto-tbody');
    const staticTbody = document.getElementById('static-tbody');
    const exportBtn = document.getElementById('export-btn');
    const importBtn = document.getElementById('import-btn');
    const csvImportInput = document.getElementById('csv-import');
    const exportHistoryBtn = document.getElementById('export-history-btn');
    const importHistoryBtn = document.getElementById('import-history-btn');
    const historyCsvImport = document.getElementById('history-csv-import');
    const getStocksPricesBtn = document.getElementById('get-stocks-prices-btn');
    const getEtfsPricesBtn = document.getElementById('get-etfs-prices-btn');
    const getCryptoPricesBtn = document.getElementById('get-crypto-prices-btn');
    // --- VALIDATED PORTFOLIO HISTORY ---
    function loadValidatedHistory() {
        try {
            const data = localStorage.getItem('portfolioPilotValidatedHistory');
            if (data) return JSON.parse(data);
        } catch {}
        return [];
    }

    function saveValidatedHistory(history) {
        localStorage.setItem('portfolioPilotValidatedHistory', JSON.stringify(history));
    }

    function exportValidatedHistoryToCsv() {
        let csvContent = 'data:text/csv;charset=utf-8,';
        csvContent += 'date,stocks,etfs,crypto,static,cs2,savings,emergency,cash,total,eur,usd,btc,eth\r\n';
        const validatedHistory = loadValidatedHistory();
        validatedHistory.forEach(entry => {
            csvContent += `${entry.date},${entry.stocks ?? 0},${entry.etfs ?? 0},${entry.crypto ?? 0},${entry.static ?? 0},${entry.cs2 ?? 0},${entry.savings ?? 0},${entry.emergency ?? 0},${entry.cash ?? 0},${entry.total ?? 0},${entry.eur ?? ''},${entry.usd ?? ''},${entry.btc ?? ''},${entry.eth ?? ''}\r\n`;
        });
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', 'portfolio_validated_history.csv');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function importValidatedHistoryFromCsv(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const rows = text.split('\r\n').filter(row => row.length > 0);
            if (rows.length < 2) {
                alert('CSV file is empty or invalid.');
                return;
            }
            // Parse header for flexible column order
            const header = rows[0].split(',');
            const idx = name => header.indexOf(name);
            const history = [];
            for (let i = 1; i < rows.length; i++) {
                const cols = rows[i].split(',');
                if (!cols.length || !cols[0]) continue;
                history.push({
                    date: cols[idx('date')],
                    stocks: parseFloat(cols[idx('stocks')] ?? 0) || 0,
                    etfs: parseFloat(cols[idx('etfs')] ?? 0) || 0,
                    crypto: parseFloat(cols[idx('crypto')] ?? 0) || 0,
                    static: parseFloat(cols[idx('static')] ?? 0) || 0,
                    cs2: parseFloat(cols[idx('cs2')] ?? 0) || 0,
                    savings: parseFloat(cols[idx('savings')] ?? 0) || 0,
                    emergency: parseFloat(cols[idx('emergency')] ?? 0) || 0,
                    cash: parseFloat(cols[idx('cash')] ?? 0) || 0,
                    total: parseFloat(cols[idx('total')] ?? 0) || 0,
                    eur: parseFloat(cols[idx('eur')] ?? 0) || 0,
                    usd: parseFloat(cols[idx('usd')] ?? 0) || 0,
                    btc: parseFloat(cols[idx('btc')] ?? 0) || 0,
                    eth: parseFloat(cols[idx('eth')] ?? 0) || 0
                });
            }
            saveValidatedHistory(history);
            updateChart();
            updateMultiCurrencyChart();
            alert('Portfolio validated history imported successfully!');
        };
        reader.readAsText(file);
    }
    exportHistoryBtn.addEventListener('click', exportValidatedHistoryToCsv);
    importHistoryBtn.addEventListener('click', () => historyCsvImport.click());
    historyCsvImport.addEventListener('change', importValidatedHistoryFromCsv);

    // --- API FUNCTIONS ---
    async function fetchStockPrice(ticker) {
        // Use Yahoo Finance endpoint for last close price
        try {
            // Use a public CORS proxy (e.g. allorigins)
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=5d`;
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl);
            const proxyData = await response.json();
            const data = JSON.parse(proxyData.contents);
            // Get the last close price from the result
            const result = data.chart?.result?.[0];
            if (!result) {
                console.error(`Could not fetch price for stock: ${ticker}`, data);
                return null;
            }
            const closeArr = result.indicators?.quote?.[0]?.close;
            if (!closeArr || !closeArr.length) {
                console.error(`No close prices for stock: ${ticker}`, data);
                return null;
            }
            // Find the last non-null close price
            let price = null;
            for (let i = closeArr.length - 1; i >= 0; i--) {
                if (typeof closeArr[i] === 'number') {
                    price = closeArr[i];
                    break;
                }
            }
            if (!price) {
                console.error(`No valid close price for stock: ${ticker}`, data);
                return null;
            }
            return price;
        } catch (error) {
            console.error(`Error fetching stock price for ${ticker}:`, error);
            return null;
        }
    }

    async function fetchCryptoPrice(id) {
        // CoinGecko API uses 'ids' not tickers. We need a mapping for common ones.
        const idMap = {
            'BTC': 'bitcoin',
            'ETH': 'ethereum',
            'DOGE': 'dogecoin',
            // Add more common mappings here
        };
        const searchId = idMap[id.toUpperCase()] || id.toLowerCase();
        // Accept currency argument, default to USD
        let vsCurrency = 'usd';
        if (arguments.length > 1 && arguments[1]) {
            vsCurrency = arguments[1].toLowerCase();
        }
        const url = `https://api.coingecko.com/api/v3/simple/price?ids=${searchId}&vs_currencies=${vsCurrency}`;
        try {
            const response = await fetch(url);
            const data = await response.json();
            const price = data[searchId]?.[vsCurrency];
            if (!price) console.error(`Could not fetch price for crypto: ${id} (searched for ${searchId})`, data);
            return price;
        } catch (error) {
            console.error(`Error fetching crypto price for ${id}:`, error);
            return null;
        }
    }


    // --- RENDERING & UI ---
    // --- Price Cache for Get Prices button ---
    let priceCache = { stocks: {}, crypto: {} };

    // Load price cache from localStorage if available
    function loadPriceCache() {
        try {
            const cache = localStorage.getItem('portfolioPilotPriceCache');
            if (cache) {
                priceCache = JSON.parse(cache);
            }
        } catch (e) {
            priceCache = { stocks: {}, crypto: {} };
        }
    }

    // Save price cache to localStorage
    function savePriceCache() {
        try {
            localStorage.setItem('portfolioPilotPriceCache', JSON.stringify(priceCache));
        } catch (e) {
            // ignore
        }
    }

    // Helper to update total value bar in multiple currencies
    function getCachedCryptoRates() {
        try {
            const cached = JSON.parse(localStorage.getItem('portfolioPilotCryptoRates'));
            if (cached && cached.timestamp && Date.now() - cached.timestamp < 1000 * 60 * 60) {
                return cached;
            }
        } catch {}
        return null;
    }
    function setCachedCryptoRates(btc, eth) {
        localStorage.setItem('portfolioPilotCryptoRates', JSON.stringify({
            btc,
            eth,
            timestamp: Date.now()
        }));
    }
    function renderPortfolio() {
        function updateTotalValueBar(eurValue) {
            const elEur = document.getElementById('portfolio-total-eur');
            const elUsd = document.getElementById('portfolio-total-usd');
            const elBtc = document.getElementById('portfolio-total-btc');
            const elEth = document.getElementById('portfolio-total-eth');
            const elEurBtc = document.getElementById('eur-btc-rate-label');
            const elEurEth = document.getElementById('eur-eth-rate-label');
            if (elEur) elEur.textContent = `€${eurValue.toLocaleString(undefined, {maximumFractionDigits:2})}`;
            if (elUsd) elUsd.textContent = `$${(eurValue * eurUsdRate).toLocaleString(undefined, {maximumFractionDigits:2})}`;
            const cached = getCachedCryptoRates();
            if (cached && cached.btc && cached.eth) {
                if (elBtc) elBtc.textContent = `₿${(eurValue / cached.btc).toFixed(4)}`;
                if (elEth) elEth.textContent = `Ξ${(eurValue / cached.eth).toFixed(4)}`;
                if (elEurBtc) elEurBtc.textContent = `EUR/BTC: ₿${(1 / cached.btc).toFixed(6)}`;
                if (elEurEth) elEurEth.textContent = `EUR/ETH: Ξ${(1 / cached.eth).toFixed(6)}`;
            } else {
                if (elBtc) elBtc.textContent = '₿--';
                if (elEth) elEth.textContent = 'Ξ--';
                if (elEurBtc) elEurBtc.textContent = 'EUR/BTC: --';
                if (elEurEth) elEurEth.textContent = 'EUR/ETH: --';
            }
        }
    stocksTbody.innerHTML = '';
    etfsTbody.innerHTML = '';
    cryptoTbody.innerHTML = '';
    staticTbody.innerHTML = '';
    // Remove any previous total rows
    document.querySelectorAll('.asset-total-row').forEach(row => row.remove());

        // Calculate values for total (in EUR), but show asset values in their own currency
        let stocksValue = 0, etfsValue = 0, cryptoValue = 0, staticValue = 0, cs2Value = 0;
    // CS2 value
    if (portfolio.cs2 && typeof portfolio.cs2.value === 'number') {
        cs2Value = portfolio.cs2.value;
        if (portfolio.cs2.currency === 'USD') cs2Value = cs2Value / eurUsdRate;
    }
        let stocksPromises = portfolio.stocks.map(async stock => {
            let price = priceCache.stocks[stock.name];
            let value = price ? price * stock.quantity : 0;
            let valueEur = value;
            if (stock.currency === 'USD') valueEur = value / eurUsdRate;
            stocksValue += valueEur;
            renderStock(stock, price);
        });
        Promise.all(stocksPromises).then(() => {
            const totalUsd = stocksValue * eurUsdRate;
            const totalRow = document.createElement('tr');
            totalRow.className = 'asset-total-row';
            totalRow.innerHTML = `<td colspan="7" class="py-2 px-4 text-right font-bold text-emerald-300">Total: €${stocksValue.toLocaleString(undefined, {maximumFractionDigits:2})} / $${totalUsd.toLocaleString(undefined, {maximumFractionDigits:2})}</td>`;
            stocksTbody.parentElement.appendChild(totalRow);
        });
        let etfsPromises = portfolio.etfs.map(async etf => {
            let price = priceCache.stocks[etf.name];
            let value = price ? price * etf.quantity : 0;
            let valueEur = value;
            if (etf.currency === 'USD') valueEur = value / eurUsdRate;
            etfsValue += valueEur;
            renderStock(etf, price, 'etf');
        });
        Promise.all(etfsPromises).then(() => {
            const totalUsd = etfsValue * eurUsdRate;
            const totalRow = document.createElement('tr');
            totalRow.className = 'asset-total-row';
            totalRow.innerHTML = `<td colspan="7" class="py-2 px-4 text-right font-bold text-emerald-300">Total: €${etfsValue.toLocaleString(undefined, {maximumFractionDigits:2})} / $${totalUsd.toLocaleString(undefined, {maximumFractionDigits:2})}</td>`;
            etfsTbody.parentElement.appendChild(totalRow);
        });
        let cryptoPromises = portfolio.crypto.map(async crypto => {
            let price = priceCache.crypto[crypto.name];
            // If price is not cached, fetch in correct currency
            if (typeof price !== 'number') {
                price = await fetchCryptoPrice(crypto.name, crypto.currency || 'USD');
                priceCache.crypto[crypto.name] = price;
            }
            let value = price ? price * crypto.quantity : 0;
            let valueEur = value;
            // If asset is in USD, convert to EUR
            if (crypto.currency === 'USD') valueEur = value / eurUsdRate;
            cryptoValue += valueEur;
            renderCrypto(crypto, price);
        });
        Promise.all(cryptoPromises).then(() => {
            const totalUsd = cryptoValue * eurUsdRate;
            const totalRow = document.createElement('tr');
            totalRow.className = 'asset-total-row';
            totalRow.innerHTML = `<td colspan="7" class="py-2 px-4 text-right font-bold text-emerald-300">Total: €${cryptoValue.toLocaleString(undefined, {maximumFractionDigits:2})} / $${totalUsd.toLocaleString(undefined, {maximumFractionDigits:2})}</td>`;
            cryptoTbody.parentElement.appendChild(totalRow);
        });
        // Group static assets by type
        const staticTypes = ['Savings', 'Emergency Fund', 'Cash'];
        staticTypes.forEach(type => {
            const assetsOfType = portfolio.static.filter(asset => asset.type === type);
            let typeValue = 0;
            if (assetsOfType.length > 0) {
                // Insert a header row for the type
                staticTbody.insertAdjacentHTML('beforeend', `<tr><td colspan="3" class="py-2 px-4 font-bold text-green-400 bg-gray-900">${type}</td></tr>`);
                assetsOfType.forEach(asset => {
                    let value = 0;
                    let currency = 'EUR';
                    if (asset.values && asset.values.length > 0) {
                        const latest = asset.values.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b);
                        value = latest.value;
                        currency = latest.currency || 'EUR';
                    }
                    let valueEur = value;
                    if (currency === 'USD') valueEur = value / eurUsdRate;
                    staticValue += valueEur;
                    typeValue += valueEur;
                    renderStatic(asset);
                });
                // Add total for this static type
                const totalUsd = typeValue * eurUsdRate;
                staticTbody.insertAdjacentHTML('beforeend', `<tr class="asset-total-row"><td colspan="3" class="py-2 px-4 text-right font-bold text-emerald-300">Total: €${typeValue.toLocaleString(undefined, {maximumFractionDigits:2})} / $${totalUsd.toLocaleString(undefined, {maximumFractionDigits:2})}</td></tr>`);
            }
        });

        Promise.all([...stocksPromises, ...etfsPromises, ...cryptoPromises]).then(() => {
            // PIE CHART LOGIC
            const totalValue = stocksValue + etfsValue + cryptoValue + staticValue + cs2Value;
            updateTotalValueBar(totalValue);
            // Show static subtypes (Cash & Savings) as separate but similar colors
            const staticTypes = [
                { type: 'Savings', color: '#10b981' },
                { type: 'Emergency Fund', color: '#34d399' },
                { type: 'Cash', color: '#059669' }
            ];
            const pieLabels = [];
            const pieData = [];
            const pieColors = [];
            if (stocksValue > 0) {
                pieLabels.push('Stocks');
                pieData.push(stocksValue);
                pieColors.push('#3b82f6');
            }
            if (etfsValue > 0) {
                pieLabels.push('ETFs');
                pieData.push(etfsValue);
                pieColors.push('#6366f1');
            }
            if (cryptoValue > 0) {
                pieLabels.push('Crypto');
                pieData.push(cryptoValue);
                pieColors.push('#f59e42');
            }
            if (cs2Value > 0) {
                pieLabels.push('CS2 Items');
                pieData.push(cs2Value);
                pieColors.push('#f43f5e');
            }
            // Add each static subtype as a separate pie slice
            staticTypes.forEach(({ type, color }) => {
                let typeValue = 0;
                portfolio.static.filter(asset => asset.type === type).forEach(asset => {
                    let value = 0;
                    let currency = 'EUR';
                    if (asset.values && asset.values.length > 0) {
                        const latest = asset.values.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b);
                        value = latest.value;
                        currency = latest.currency || 'EUR';
                    }
                    let valueEur = value;
                    if (currency === 'USD') valueEur = value / eurUsdRate;
                    typeValue += valueEur;
                });
                if (typeValue > 0) {
                    pieLabels.push(type);
                    pieData.push(typeValue);
                    pieColors.push(color);
                }
            });
            if (window.pieChartInstance) {
                window.pieChartInstance.destroy();
            }
            const pieCtx = document.getElementById('pie-chart').getContext('2d');
            window.pieChartInstance = new Chart(pieCtx, {
                type: 'pie',
                data: {
                    labels: pieLabels,
                    datasets: [{
                        data: pieData,
                        backgroundColor: pieColors,
                        borderColor: '#1f2937',
                        borderWidth: 2
                    }]
                },
                options: {
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    return `${label}`;
                                }
                            }
                        }
                    }
                }
            });
        });
    // CS2 Items input logic (manual value, no currency selector)
    const cs2ValueInput = document.getElementById('cs2-value-input');
    const cs2SaveBtn = document.getElementById('save-cs2-value-btn');
    if (cs2ValueInput && cs2SaveBtn) {
        cs2ValueInput.value = portfolio.cs2 && typeof portfolio.cs2.value === 'number' ? portfolio.cs2.value : '';
        cs2SaveBtn.addEventListener('click', () => {
            const val = parseFloat(cs2ValueInput.value) || 0;
            portfolio.cs2 = { value: val, currency: 'USD' };
            saveData();
            renderPortfolio();
        });
    }

        updateChart();
    }


    function getActionButtons(id, type) {
        return `
            <button data-id="${id}" data-type="${type}" class="edit-btn p-1 hover:text-green-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
            </button>
            <button data-id="${id}" data-type="${type}" class="delete-btn p-1 hover:text-red-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        `;
    }

    function calculateGainLoss(asset, currentPrice, currency) {
    if (!currentPrice) return '...';
    let costBasis = asset.purchasePrice * asset.quantity;
    let currentValue = currentPrice * asset.quantity;
    let currencySymbol = currency === 'USD' ? '$' : '€';
    // No conversion: show gain/loss in asset's currency
    const gainLoss = currentValue - costBasis;
    const gainLossPercent = (gainLoss / costBasis) * 100;
    const gainClass = gainLoss >= 0 ? 'positive-gain' : 'negative-gain';
    return `<span class="${gainClass}">${currencySymbol}${gainLoss.toFixed(2)} (${gainLossPercent.toFixed(2)}%)</span>`;
    }

    async function renderStock(stock, cachedPrice) {
        let currentPrice = cachedPrice;
        // Only use cached price, do not fetch automatically
        let value = currentPrice ? currentPrice * stock.quantity : 0;
        let totalInvested = stock.purchasePrice * stock.quantity;
        let currencySymbol = stock.currency === 'USD' ? '$' : '€';
        const placeholder = `
            <tr data-id="${stock.id}">
                <td class="py-2 px-4 font-medium">${stock.name}</td>
                <td class="py-2 px-4">${stock.quantity}</td>
                <td class="py-2 px-4">${currencySymbol}${stock.purchasePrice.toFixed(2)}</td>
                <td class="py-2 px-4 price-cell">${typeof currentPrice === 'number' ? `${currencySymbol}${currentPrice.toFixed(2)}` : 'N/A'}</td>
                <td class="py-2 px-4">${currencySymbol}${totalInvested.toFixed(2)}</td>
                <td class="py-2 px-4 value-cell">${typeof currentPrice === 'number' ? `${currencySymbol}${value.toFixed(2)}` : 'N/A'}</td>
                <td class="py-2 px-4 gain-cell">${typeof currentPrice === 'number' ? calculateGainLoss(stock, currentPrice, stock.currency) : 'N/A'}</td>
                <td class="py-2 px-4 action-cell">${getActionButtons(stock.id, arguments[2] === 'etf' ? 'etf' : 'stock')}</td>
            </tr>`;
        if (arguments[2] === 'etf') {
            etfsTbody.insertAdjacentHTML('beforeend', placeholder);
        } else {
            stocksTbody.insertAdjacentHTML('beforeend', placeholder);
        }
    }

    async function renderCrypto(crypto, cachedPrice) {
        let currentPrice = cachedPrice;
        // Only use cached price, do not fetch automatically
        let value = currentPrice ? currentPrice * crypto.quantity : 0;
        let totalInvested = crypto.purchasePrice * crypto.quantity;
        let currencySymbol = crypto.currency === 'USD' ? '$' : '€';
        const placeholder = `
            <tr data-id="${crypto.id}">
                <td class="py-2 px-4 font-medium">${crypto.name}</td>
                <td class="py-2 px-4">${crypto.quantity}</td>
                <td class="py-2 px-4">${currencySymbol}${crypto.purchasePrice.toFixed(2)}</td>
                <td class="py-2 px-4 price-cell">${typeof currentPrice === 'number' ? `${currencySymbol}${currentPrice.toFixed(2)}` : 'N/A'}</td>
                <td class="py-2 px-4">${currencySymbol}${totalInvested.toFixed(2)}</td>
                <td class="py-2 px-4 value-cell">${typeof currentPrice === 'number' ? `${currencySymbol}${value.toFixed(2)}` : 'N/A'}</td>
                <td class="py-2 px-4 gain-cell">${typeof currentPrice === 'number' ? calculateGainLoss(crypto, currentPrice, crypto.currency) : 'N/A'}</td>
                <td class="py-2 px-4 action-cell">${getActionButtons(crypto.id, 'crypto')}</td>
            </tr>`;
        cryptoTbody.insertAdjacentHTML('beforeend', placeholder);
    }
    // --- GET PRICES BUTTON LOGIC ---
    async function getAllPricesAndRender() {
    showNotification('Fetching latest prices...', 'success');
        let updated = false;
        // Only update cache if a value is actually retrieved
        await Promise.all([
            ...portfolio.stocks.map(async stock => {
                // Use stock.ticker if available, else fallback to stock.name
                const ticker = stock.ticker || stock.name;
                const price = await fetchStockPrice(ticker);
                if (typeof price === 'number' && !isNaN(price)) {
                    priceCache.stocks[stock.name] = price;
                    updated = true;
                }
            }),
            ...portfolio.crypto.map(async crypto => {
                const price = await fetchCryptoPrice(crypto.name);
                if (typeof price === 'number' && !isNaN(price)) {
                    priceCache.crypto[crypto.name] = price;
                    updated = true;
                }
            })
        ]);
        if (updated) savePriceCache();
        renderPortfolio();
        showNotification('Prices updated!', 'success');
    }

    function getStaticValueOnDate(asset, dateStr) {
        // asset.values: [{date, value, currency}]
        if (!asset.values || asset.values.length === 0) return 0;
        // Find the most recent value on or before dateStr
        const date = new Date(dateStr);
        let best = null;
        for (const entry of asset.values) {
            const entryDate = new Date(entry.date);
            if (entryDate <= date && (!best || entryDate > new Date(best.date))) {
                best = entry;
            }
        }
        return best ? best.value : 0;
    }

    function renderStatic(asset) {
        // Show the latest value
        let value = 0;
        let currency = 'EUR';
        if (asset.values && asset.values.length > 0) {
            // Find the latest value
            const latest = asset.values.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b);
            value = latest.value;
            currency = latest.currency || 'EUR';
        }
        let currencySymbol = currency === 'USD' ? '$' : '€';
        const row = `
            <tr data-id="${asset.id}">
                <td class="py-2 px-4 font-medium">${asset.name}</td>
                <td class="py-2 px-4">${currencySymbol}${value.toFixed(2)}</td>
                <td class="py-2 px-4">${getActionButtons(asset.id, 'static')}</td>
            </tr>`;
        staticTbody.insertAdjacentHTML('beforeend', row);
    // Show/hide static type field based on asset type
    const assetTypeSelect = document.getElementById('asset-type');
    const staticTypeField = document.getElementById('static-type-field');

    function calculateGainLoss(asset, currentPrice, currency) {
        if (!currentPrice) return '...';
        let costBasis = asset.purchasePrice * asset.quantity;
        let currentValue = currentPrice * asset.quantity;
        if (currency === 'USD') {
            costBasis = costBasis / eurUsdRate;
            currentValue = currentValue / eurUsdRate;
        }
        const gainLoss = currentValue - costBasis;
        const gainLossPercent = (gainLoss / costBasis) * 100;
        const gainClass = gainLoss >= 0 ? 'positive-gain' : 'negative-gain';
        return `<span class="${gainClass}">€${gainLoss.toFixed(2)} (${gainLossPercent.toFixed(2)}%)</span>`;
    }

    function getActionButtons(id, type) {
        return `
            <button data-id="${id}" data-type="${type}" class="edit-btn p-1 hover:text-green-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
            </button>
            <button data-id="${id}" data-type="${type}" class="delete-btn p-1 hover:text-red-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        `;
    }

    function openModal(mode = 'add', type = 'stock', asset = null) {
        assetForm.reset();
        modalTitle.textContent = mode === 'add' ? 'Add New Asset' : 'Edit Asset';
        assetIdInput.value = asset ? asset.id : '';
        assetTypeSelect.disabled = mode === 'edit';

        if (mode === 'add') {
            assetTypeSelect.value = type;
        } else if (asset) {
            assetTypeSelect.value = type;
            assetNameInput.value = asset.name;
            if (type !== 'static') {
                assetQuantityInput.value = asset.quantity;
                assetPurchasePriceInput.value = asset.purchasePrice;
            } else {
                assetQuantityInput.value = asset.quantity;
            }
        }

        updateModalFields();
        modal.classList.remove('hidden');
    }

    function closeModal() {
        modal.classList.add('hidden');
    }

    function updateModalFields() {
        const type = assetTypeSelect.value;
        if (type === 'static') {
            const staticType = document.getElementById('static-type').value;
            const staticAsset = {
                id,
                name,
                type: staticType,
                values: [{ date: new Date().toISOString().split('T')[0], value, currency }]
            };
            if (editIndex !== -1) {
                portfolio.static[editIndex] = staticAsset;
            } else {
                portfolio.static.push(staticAsset);
            }
        }
            quantityField.querySelector('label').textContent = 'Value';
            assetQuantityInput.placeholder = 'e.g., 20000';
            quantityField.classList.remove('hidden');
            purchasePriceField.classList.add('hidden');
        }
    }

    // --- CHART LOGIC ---
    function initializeChart() {
        const ctx = document.getElementById('portfolio-chart').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [], // Dates
                datasets: [
                    {
                        label: 'Total Value',
                        data: [],
                        borderColor: '#10b981', // emerald-500
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 3,
                        tension: 0.1,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: false,
                        ticks: { color: '#9ca3af' },
                        grid: { color: '#374151' }
                    },
                    x: {
                        ticks: { color: '#9ca3af' },
                        grid: { color: '#374151' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#d1d5db' }
                    }
                }
            }
        });
    }

    async function updateChart() {
        // Only show validated history, with all asset types
        const validatedHistory = loadValidatedHistory();
        if (!validatedHistory.length) {
            chartInstance.data.labels = [];
            chartInstance.data.datasets = [];
            chartInstance.update();
            return;
        }
        validatedHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        const labels = validatedHistory.map(h => h.date);
        chartInstance.data.labels = labels;
        chartInstance.data.datasets = [
            {
                label: 'Total',
                data: validatedHistory.map(h => h.total),
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 3,
                tension: 0.1,
                fill: false
            },
            {
                label: 'Stocks',
                data: validatedHistory.map(h => h.stocks),
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                borderWidth: 2,
                tension: 0.1,
                fill: false
            },
            {
                label: 'ETFs',
                data: validatedHistory.map(h => h.etfs || 0),
                borderColor: '#6366f1',
                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                borderWidth: 2,
                tension: 0.1,
                fill: false
            },
            {
                label: 'Crypto',
                data: validatedHistory.map(h => h.crypto),
                borderColor: '#f59e42',
                backgroundColor: 'rgba(245, 158, 66, 0.1)',
                borderWidth: 2,
                tension: 0.1,
                fill: false
            },
            {
                label: 'CS2',
                data: validatedHistory.map(h => h.cs2 || 0),
                borderColor: '#f43f5e',
                backgroundColor: 'rgba(244, 63, 94, 0.1)',
                borderWidth: 2,
                tension: 0.1,
                fill: false
            },
            {
                label: 'Savings',
                data: validatedHistory.map(h => h.savings || 0),
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                borderWidth: 2,
                borderDash: [5, 5],
                tension: 0.1,
                fill: false
            },
            {
                label: 'Emergency Fund',
                data: validatedHistory.map(h => h.emergency || 0),
                borderColor: '#34d399',
                backgroundColor: 'rgba(52, 211, 153, 0.1)',
                borderWidth: 2,
                borderDash: [5, 5],
                tension: 0.1,
                fill: false
            },
            {
                label: 'Cash',
                data: validatedHistory.map(h => h.cash || 0),
                borderColor: '#059669',
                backgroundColor: 'rgba(5, 150, 105, 0.1)',
                borderWidth: 2,
                borderDash: [5, 5],
                tension: 0.1,
                fill: false
            }
        ];
        chartInstance.update();
    }
    // --- VALIDATE TO HISTORY BUTTON ---
    document.getElementById('validate-history-btn').addEventListener('click', () => {
        // Calculate current values for each asset type
    let stocksValue = 0, etfsValue = 0, cryptoValue = 0, staticValue = 0, cs2Value = 0;
    let savingsValue = 0, emergencyValue = 0, cashValue = 0;
        portfolio.stocks.forEach(stock => {
            let price = priceCache.stocks[stock.name];
            let value = price ? price * stock.quantity : 0;
            let valueEur = value;
            if (stock.currency === 'USD') valueEur = value / eurUsdRate;
            stocksValue += valueEur;
        });
        portfolio.etfs.forEach(etf => {
            let price = priceCache.stocks[etf.name];
            let value = price ? price * etf.quantity : 0;
            let valueEur = value;
            if (etf.currency === 'USD') valueEur = value / eurUsdRate;
            etfsValue += valueEur;
        });
        portfolio.crypto.forEach(crypto => {
            let price = priceCache.crypto[crypto.name];
            let value = price ? price * crypto.quantity : 0;
            let valueEur = value;
            if (crypto.currency === 'USD') valueEur = value / eurUsdRate;
            cryptoValue += valueEur;
        });
        portfolio.static.forEach(asset => {
            let value = 0;
            let currency = 'EUR';
            if (asset.values && asset.values.length > 0) {
                const latest = asset.values.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b);
                value = latest.value;
                currency = latest.currency || 'EUR';
            }
            let valueEur = value;
            if (currency === 'USD') valueEur = value / eurUsdRate;
            staticValue += valueEur;
            // Subtype breakdown
            if (asset.type === 'Savings') savingsValue += valueEur;
            else if (asset.type === 'Emergency Fund') emergencyValue += valueEur;
            else if (asset.type === 'Cash') cashValue += valueEur;
        });
        // CS2 value
        if (portfolio.cs2 && typeof portfolio.cs2.value === 'number') {
            cs2Value = portfolio.cs2.value;
            if (portfolio.cs2.currency === 'USD') cs2Value = cs2Value / eurUsdRate;
        }
        const totalValue = stocksValue + etfsValue + cryptoValue + staticValue + cs2Value;
        // Calculate multi-currency values
        const cached = getCachedCryptoRates();
        const eur = totalValue;
        const usd = eur * eurUsdRate;
        const btc = cached && cached.btc ? eur / cached.btc : null;
        const eth = cached && cached.eth ? eur / cached.eth : null;
        const today = new Date().toISOString().slice(0,10);
        let validatedHistory = loadValidatedHistory();
        // Remove any entry for today
        validatedHistory = validatedHistory.filter(h => h.date !== today);
        validatedHistory.push({
            date: today,
            stocks: stocksValue,
            etfs: etfsValue,
            crypto: cryptoValue,
            static: staticValue,
            cs2: cs2Value,
            savings: savingsValue,
            emergency: emergencyValue,
            cash: cashValue,
            total: totalValue,
            eur,
            usd,
            btc,
            eth
        });
        saveValidatedHistory(validatedHistory);
        updateChart();
        updateMultiCurrencyChart();
        showNotification('Portfolio value validated to history!', 'success');
    });
    
    // --- DATA HANDLING (Save/Load/CSV) ---
    function showNotification(message, type = 'success') {
        let notif = document.createElement('div');
        notif.textContent = message;
        notif.className = `fixed top-6 right-6 z-50 px-4 py-2 rounded-lg shadow-lg text-white font-bold transition duration-300 ${type === 'success' ? 'bg-green-600' : 'bg-red-600'}`;
        document.body.appendChild(notif);
        setTimeout(() => notif.remove(), 2000);
    }

    function saveData() {
        try {
            localStorage.setItem('portfolioPilotData', JSON.stringify(portfolio));
            showNotification('Assets saved!', 'success');
        } catch (e) {
            showNotification('Error saving assets!', 'error');
            console.error('localStorage error:', e);
        }
    }

    function loadData() {
        try {
            const data = localStorage.getItem('portfolioPilotData');
            if (data) {
                portfolio = JSON.parse(data);
                // Migrate static assets to time series if needed
                if (portfolio.static && portfolio.static.length > 0 && !portfolio.static[0].values) {
                    portfolio.static = portfolio.static.map(asset => ({
                        id: asset.id,
                        name: asset.name,
                        values: [{ date: new Date().toISOString().slice(0,10), value: asset.quantity, currency: asset.currency || 'EUR' }]
                    }));
                }
            } else {
                // Add some default data for first-time users
                portfolio = {
                    stocks: [
                        {id: Date.now() + 1, name: "AAPL", quantity: 10, purchasePrice: 150.00, currency: "USD"},
                        {id: Date.now() + 2, name: "MSFT", quantity: 15, purchasePrice: 300.00, currency: "USD"}
                    ],
                    crypto: [
                        {id: Date.now() + 3, name: "BTC", quantity: 0.5, purchasePrice: 40000.00, currency: "USD"}
                    ],
                    static: [
                        {id: Date.now() + 4, name: "Emergency Fund", values: [{date: new Date().toISOString().slice(0,10), value: 20000, currency: "EUR"}]},
                        {id: Date.now() + 5, name: "High-Yield Savings", values: [{date: new Date().toISOString().slice(0,10), value: 50000, currency: "EUR"}]}
                    ]
                };
            }
            // Ensure portfolio always has all keys
            if (!portfolio.stocks) portfolio.stocks = [];
            if (!portfolio.etfs) portfolio.etfs = [];
            if (!portfolio.crypto) portfolio.crypto = [];
            if (!portfolio.static) portfolio.static = [];
            renderPortfolio();
        } catch (e) {
            showNotification('Error loading assets!', 'error');
            console.error('localStorage error:', e);
            // Fallback to default structure
            portfolio = { stocks: [], crypto: [], static: [] };
            renderPortfolio();
        }
    }

    function exportToCsv() {
        let csvContent = "data:text/csv;charset=utf-8,";
        // Add staticType column for static assets
        csvContent += "type,name,staticType,quantity,purchasePrice,currency\r\n";
        portfolio.stocks.forEach(asset => {
            csvContent += `stock,${asset.name},,${asset.quantity},${asset.purchasePrice},${asset.currency || 'USD'}\r\n`;
        });
        portfolio.etfs.forEach(asset => {
            csvContent += `etf,${asset.name},,${asset.quantity},${asset.purchasePrice},${asset.currency || 'USD'}\r\n`;
        });
        portfolio.crypto.forEach(asset => {
            csvContent += `crypto,${asset.name},,${asset.quantity},${asset.purchasePrice},${asset.currency || 'USD'}\r\n`;
        });
        portfolio.static.forEach(asset => {
            // Use latest value for static asset
            let latest = { value: 0, currency: 'EUR' };
            if (asset.values && asset.values.length > 0) {
                latest = asset.values.reduce((a, b) => new Date(a.date) > new Date(b.date) ? a : b);
            }
            csvContent += `static,${asset.name},${asset.type || ''},${latest.value},0,${latest.currency || 'EUR'}\r\n`;
        });
        // CS2 asset
        if (portfolio.cs2 && typeof portfolio.cs2.value === 'number' && portfolio.cs2.value > 0) {
            csvContent += `cs2,CS2 Inventory,,${portfolio.cs2.value},0,${portfolio.cs2.currency || 'USD'}\r\n`;
        }
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "portfolio.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function importFromCsv(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const rows = text.split('\r\n').filter(row => row.length > 0);
            if (rows.length < 2) {
                alert("CSV file is empty or invalid.");
                return;
            }
            // Detect header columns
            const header = rows[0].split(',');
            // type,name,staticType,quantity,purchasePrice,currency
            const typeIdx = header.indexOf('type');
            const nameIdx = header.indexOf('name');
            const staticTypeIdx = header.indexOf('staticType');
            const quantityIdx = header.indexOf('quantity');
            const purchasePriceIdx = header.indexOf('purchasePrice');
            const currencyIdx = header.indexOf('currency');
            const newPortfolio = { stocks: [], etfs: [], crypto: [], static: [], cs2: { value: 0, currency: 'EUR' } };
            const today = new Date().toISOString().slice(0,10);
            for (let i = 1; i < rows.length; i++) {
                const cols = rows[i].split(',');
                const type = cols[typeIdx];
                const name = cols[nameIdx];
                const staticType = staticTypeIdx !== -1 ? cols[staticTypeIdx] : '';
                const quantity = cols[quantityIdx];
                const purchasePrice = purchasePriceIdx !== -1 ? cols[purchasePriceIdx] : '';
                const currency = currencyIdx !== -1 ? cols[currencyIdx] : '';
                if (!type || !name) continue;
                if (type === 'stock' && quantity) {
                    newPortfolio.stocks.push({
                        id: Date.now() + i,
                        name: name.trim(),
                        quantity: parseFloat(quantity),
                        purchasePrice: parseFloat(purchasePrice),
                        currency: currency ? currency.trim() : 'USD'
                    });
                } else if (type === 'etf' && quantity) {
                    newPortfolio.etfs.push({
                        id: Date.now() + i,
                        name: name.trim(),
                        quantity: parseFloat(quantity),
                        purchasePrice: parseFloat(purchasePrice),
                        currency: currency ? currency.trim() : 'USD'
                    });
                } else if (type === 'crypto' && quantity) {
                    newPortfolio.crypto.push({
                        id: Date.now() + i,
                        name: name.trim(),
                        quantity: parseFloat(quantity),
                        purchasePrice: parseFloat(purchasePrice),   
                        currency: currency ? currency.trim() : 'USD'
                    });
                } else if (type === 'static' && quantity) {
                    // Use staticType column if present, else fallback to name
                    let sType = staticType && staticType.trim() ? staticType.trim() : name.trim();
                    let staticName = name.trim();
                    newPortfolio.static.push({
                        id: Date.now() + i,
                        name: staticName,
                        type: sType,
                        values: [{ date: today, value: parseFloat(quantity), currency: currency ? currency.trim() : 'EUR' }]
                    });
                } else if (type === 'cs2' && quantity) {
                    newPortfolio.cs2 = { value: parseFloat(quantity), currency: currency ? currency.trim() : 'USD' };
                }
            }
            // Only show success if at least one asset was imported
            const totalImported = newPortfolio.stocks.length + newPortfolio.etfs.length + newPortfolio.crypto.length + newPortfolio.static.length + (newPortfolio.cs2.value > 0 ? 1 : 0);
            if (totalImported > 0) {
                portfolio = newPortfolio;
                saveData();
                renderPortfolio();
                alert('Portfolio imported successfully!');
            } else {
                alert('No valid assets found in CSV. Please check the format.');
            }
        };
        reader.readAsText(file);
    }
    
    // --- MODAL FUNCTIONS ---
    function openModal(mode = 'add', type = 'stock', asset = null) {
        assetForm.reset();
        modalTitle.textContent = mode === 'add' ? 'Add New Asset' : 'Edit Asset';
        assetIdInput.value = asset ? asset.id : '';
        // Disable asset type select if adding from a section, enable only for edit or generic add
        if (mode === 'add') {
            assetTypeSelect.value = type;
            assetTypeSelect.disabled = true;
            } else if (asset) { 
                assetTypeSelect.value = type; 
                assetTypeSelect.disabled = true; 
                assetNameInput.value = asset.name; 
                if (type !== 'static') { 
                    assetQuantityInput.value = asset.quantity; 
                    assetPurchasePriceInput.value = asset.purchasePrice; 
                } else { 
                    assetQuantityInput.value = asset.quantity; 
                    // Lock static-type when editing 
                    const staticTypeSelect = document.getElementById('static-type'); 
                    if (staticTypeSelect) { 
                        staticTypeSelect.value = asset.type || ''; 
                        staticTypeSelect.disabled = true; 
                    } 
                } 
            } else { 
                assetTypeSelect.disabled = false; 
                // For static, unlock static-type 
                if (type === 'static') { 
                    const staticTypeSelect = document.getElementById('static-type'); 
                    if (staticTypeSelect) staticTypeSelect.disabled = false; 
                } 
            } 
        updateModalFields();
        modal.classList.remove('hidden');
    }
    function closeModal() {
        modal.classList.add('hidden');
    }
    function updateModalFields() {
        const type = assetTypeSelect.value;
        if (type === 'static') {
            staticTypeField.classList.remove('hidden');
            assetNameLabel.textContent = 'Name';
            assetNameInput.placeholder = 'e.g., Emergency Fund';
            // Show only the value field, hide quantity and purchase price fields
            quantityField.querySelector('label').textContent = 'Value';
            assetQuantityInput.placeholder = 'e.g., 20000';
            quantityField.classList.remove('hidden');
            purchasePriceField.classList.add('hidden');
            // Remove required attribute from purchase price input
            assetPurchasePriceInput.required = false;
        } else {
            staticTypeField.classList.add('hidden');
            assetNameLabel.textContent = 'Ticker (e.g., AAPL)';
            assetNameInput.placeholder = 'e.g., AAPL';
            quantityField.querySelector('label').textContent = 'Quantity';
            assetQuantityInput.placeholder = 'e.g., 10';
            quantityField.classList.remove('hidden');
            purchasePriceField.classList.remove('hidden');
            // Restore required attribute for purchase price input
            assetPurchasePriceInput.required = true;
        }
    }

    // --- EVENT LISTENERS ---
    // addAssetBtn.addEventListener('click', () => openModal('add'));
    if (addStockBtn) addStockBtn.addEventListener('click', () => openModal('add', 'stock'));
    if (addEtfBtn) addEtfBtn.addEventListener('click', () => openModal('add', 'etf'));
    if (addCryptoBtn) addCryptoBtn.addEventListener('click', () => openModal('add', 'crypto'));
    if (addStaticBtn) addStaticBtn.addEventListener('click', () => openModal('add', 'static'));
    cancelBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    assetTypeSelect.addEventListener('change', updateModalFields);
    
    assetForm.addEventListener('submit', (e) => {
        e.preventDefault();
        let type = assetTypeSelect.value;
        // Map type to portfolio key
        const typeMap = { stock: 'stocks', etf: 'etfs', crypto: 'crypto', static: 'static' };
        const portfolioKey = typeMap[type];
        if (!portfolioKey || !portfolio[portfolioKey]) {
            console.error('Unexpected asset type:', type);
            showNotification('Invalid asset type! (' + type + ')', 'error');
            return;
        }
        const id = assetIdInput.value;

        const assetName = assetNameInput.value.trim();
        const assetQuantity = parseFloat(assetQuantityInput.value);
        const assetPurchasePrice = parseFloat(assetPurchasePriceInput.value);
        const assetCurrency = assetCurrencySelect.value;

        if (type === 'static') {
            // For static, add a new value entry for today
            const today = new Date().toISOString().slice(0,10);
            const staticTypeSelect = document.getElementById('static-type');
            const staticType = staticTypeSelect ? staticTypeSelect.value : '';
            if (id) { // Editing existing static asset
                const index = portfolio.static.findIndex(a => a.id === parseInt(id));
                if (index > -1) {
                    // Add or update value for today
                    let asset = portfolio.static[index];
                    if (!asset.values) asset.values = [];
                    // Remove any value for today
                    asset.values = asset.values.filter(v => v.date !== today);
                    asset.values.push({date: today, value: assetQuantity, currency: assetCurrency});
                    asset.name = assetName;
                    asset.type = staticType;
                }
            } else { // New static asset
                portfolio.static.push({
                    id: Date.now(),
                    name: assetName,
                    type: staticType,
                    values: [{date: today, value: assetQuantity, currency: assetCurrency}]
                });
            }
        } else {
            // Stocks and crypto logic unchanged
            const assetData = {
                id: id ? parseInt(id) : Date.now(),
                name: assetName.toUpperCase(),
                quantity: assetQuantity,
                purchasePrice: assetPurchasePrice,
                currency: assetCurrency
            };
            if (id) { // Editing existing asset
                const index = portfolio[portfolioKey].findIndex(a => a.id === assetData.id);
                if (index > -1) {
                    portfolio[portfolioKey][index] = assetData;
                }
            } else { // Adding new asset
                // For stocks and crypto, check if asset with same name exists
                const existingIndex = portfolio[portfolioKey].findIndex(a => a.name === assetData.name);
                if (existingIndex > -1) {
                    // Sum quantities and average price
                    const existing = portfolio[portfolioKey][existingIndex];
                    const totalQuantity = existing.quantity + assetQuantity;
                    // Weighted average price
                    const avgPrice = ((existing.quantity * existing.purchasePrice) + (assetQuantity * assetPurchasePrice)) / totalQuantity;
                    portfolio[portfolioKey][existingIndex] = {
                        ...existing,
                        quantity: totalQuantity,
                        purchasePrice: avgPrice
                    };
                } else {
                    portfolio[portfolioKey].push(assetData);
                }
            }
        }

        saveData();
        renderPortfolio();
        closeModal();
    });

    exportBtn.addEventListener('click', exportToCsv);
    importBtn.addEventListener('click', () => csvImportInput.click());
    csvImportInput.addEventListener('change', importFromCsv);

    // Event delegation for edit/delete buttons
    [stocksTbody, cryptoTbody, staticTbody].forEach(tbody => {
// ETFs event delegation
etfsTbody.addEventListener('click', function(e) {
    const editBtn = e.target.closest('.edit-btn');
    const deleteBtn = e.target.closest('.delete-btn');
    if (editBtn) {
        const id = parseInt(editBtn.dataset.id);
        const asset = portfolio.etfs.find(a => a.id === id);
        openModal('edit', 'etf', asset);
    }
    if (deleteBtn) {
        const id = parseInt(deleteBtn.dataset.id);
        if (confirm('Are you sure you want to delete this asset?')) {
            portfolio.etfs = portfolio.etfs.filter(a => a.id !== id);
            saveData();
            renderPortfolio();
        }
    }
});
        tbody.addEventListener('click', function(e) {
            const editBtn = e.target.closest('.edit-btn');
            const deleteBtn = e.target.closest('.delete-btn');
            if (editBtn) {
                const id = parseInt(editBtn.dataset.id);
                const type = editBtn.dataset.type;
                let key;
                if (type === 'stock') key = 'stocks';
                else if (type === 'crypto') key = 'crypto';
                else if (type === 'static') key = 'static';
                else return;
                const asset = portfolio[key].find(a => a.id === id);
                openModal('edit', type, asset);
            }
            if (deleteBtn) {
                const id = parseInt(deleteBtn.dataset.id);
                const type = deleteBtn.dataset.type;
                if (confirm('Are you sure you want to delete this asset?')) {
                    let key;
                    if (type === 'stock') key = 'stocks';
                    else if (type === 'crypto') key = 'crypto';
                    else if (type === 'static') key = 'static';
                    else return;
                    portfolio[key] = portfolio[key].filter(a => a.id !== id);
                    saveData();
                    renderPortfolio();
                }
            }
        });
    });

    // --- INITIALIZATION ---
    initializeChart();
    loadPriceCache();
    loadExchangeRate();
    loadData();

    // --- Per-section Get Prices Buttons --- 
    if (getStocksPricesBtn) {
        getStocksPricesBtn.addEventListener('click', async () => {
            getStocksPricesBtn.disabled = true;
            getStocksPricesBtn.textContent = 'Fetching...';
            let updated = false;
            await Promise.all(
                portfolio.stocks.map(async stock => {
                    const price = await fetchStockPrice(stock.name);
                    if (typeof price === 'number' && !isNaN(price)) {
                        priceCache.stocks[stock.name] = price;
                        updated = true;
                    }
                })
            );
            if (updated) savePriceCache();
            renderPortfolio();
            showNotification('Stock prices updated!', 'success');
            getStocksPricesBtn.disabled = false;
            getStocksPricesBtn.textContent = 'Get Prices';
        });
    }
    if (getEtfsPricesBtn) {
        getEtfsPricesBtn.addEventListener('click', async () => {
            getEtfsPricesBtn.disabled = true;
            getEtfsPricesBtn.textContent = 'Fetching...';
            let updated = false;
            await Promise.all(
                portfolio.etfs.map(async etf => {
                    const price = await fetchStockPrice(etf.name);
                    if (typeof price === 'number' && !isNaN(price)) {
                        priceCache.stocks[etf.name] = price;
                        updated = true;
                    }
                })
            );
            if (updated) savePriceCache();
            renderPortfolio();
            showNotification('ETF prices updated!', 'success');
            getEtfsPricesBtn.disabled = false;
            getEtfsPricesBtn.textContent = 'Get Prices';
        });
    }
    if (getCryptoPricesBtn) {
        getCryptoPricesBtn.addEventListener('click', async () => {
            getCryptoPricesBtn.disabled = true;
            getCryptoPricesBtn.textContent = 'Fetching...';
            let updated = false;
            await Promise.all(
                portfolio.crypto.map(async crypto => {
                    const price = await fetchCryptoPrice(crypto.name);
                    if (typeof price === 'number' && !isNaN(price)) {
                        priceCache.crypto[crypto.name] = price;
                        updated = true;
                    }
                })
            );
            if (updated) savePriceCache();
            renderPortfolio();
            showNotification('Crypto prices updated!', 'success');
            getCryptoPricesBtn.disabled = false;
            getCryptoPricesBtn.textContent = 'Get Prices';
        });
    }
    // Removed get-exchange-rate-btn event listener

    // --- FETCH CRYPTO RATES BUTTON LOGIC ---
    const fetchCryptoRatesBtn = document.getElementById('fetch-crypto-rates-btn');
    if (fetchCryptoRatesBtn) {
        fetchCryptoRatesBtn.addEventListener('click', async () => {
            fetchCryptoRatesBtn.disabled = true;
            fetchCryptoRatesBtn.textContent = 'Fetching...';
            try {
                const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=eur');
                const data = await res.json();
                if (data.bitcoin && data.bitcoin.eur && data.ethereum && data.ethereum.eur) {
                    setCachedCryptoRates(data.bitcoin.eur, data.ethereum.eur);
                    showNotification('Crypto rates updated!', 'success');
                    renderPortfolio();
                } else {
                    showNotification('Failed to fetch crypto rates: ' + JSON.stringify(data), 'error');
                }
            } catch (e) {
                showNotification('Error fetching crypto rates: ' + (e && e.message ? e.message : e), 'error');
            }
            fetchCryptoRatesBtn.disabled = false;
            fetchCryptoRatesBtn.textContent = 'Fetch Crypto Rates';
        });
    }
});
</script>

</body>
</html>

